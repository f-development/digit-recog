<!DOCTYPE html>
<html>

<head>
  <title>Implementing deep learning from scratch with C++</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta name="robots" content="noindex">

  <link rel="stylesheet" href="/css/mystyle.css">
  <script type="text/javascript" src="/lib/jquery/jquery.js"></script>
  <script type="text/javascript" src="handwriting_network.js"></script>
  <script type="text/javascript" src="neural_network.js"></script>
  <script>
    let canvas = null;
    let container = null;
    let context = null;
    let isDrawingNow = false;
    var currentPoint = null;

    let info1 = null;
    let info2 = null;
    let info3 = null;

    $(document).ready(function() {
      canvas = document.getElementById('input-canvas');
      canvas.onmousedown = mouseDown;
      canvas.onmouseup = mouseUp;
      canvas.onmousemove = mouseMove;
      container = document.getElementById('out-of-canvas');
      container.onmousedown = reset;

      canvas.addEventListener("touchstart", (event) => {
        event.preventDefault();
        touchStart(event);
      }, false);

      canvas.addEventListener("touchend", (event) => {
        event.preventDefault();
        touchEnd(event);
      }, false);

      canvas.addEventListener("touchmove", (event) => {
        event.preventDefault();
        touchMove(event);
      }, false);

      // Stop drawing if mouse goes out of canvas.
      $(document).mousemove(function() {
        isDrawingNow = false;
      });

      context = canvas.getContext('2d');
      context.lineWidth = 20;
      context.lineJoin = 'round';
      context.lineCap = 'round';
    });

    function touchStart(event) {
      isDrawingNow = true;

      var touch = event.touches[0];
      const x = event.changedTouches[0].pageX - canvas.getBoundingClientRect().left
      const y = event.changedTouches[0].pageY - canvas.getBoundingClientRect().top

      currentPoint = [x, y];

      event.stopPropagation();
    }

    function touchEnd(event) {
      isDrawingNow = false;
    }

    function touchMove(event) {
      if (isDrawingNow === false) {
        return;
      }

      var touch = event.touches[0];
      const x = event.changedTouches[0].pageX - canvas.getBoundingClientRect().left
      const y = event.changedTouches[0].pageY - canvas.getBoundingClientRect().top

      if (Math.abs(x - currentPoint[0] < 0.1)) {
        //return;
      }

      drawLine(currentPoint, [x, y]);
      currentPoint = [x, y];

      event.stopPropagation();
    }

    function reset() {
      resetCanvas();
      resetDisplay();
    }

    function resetCanvas() {
      context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function canvasClicked(event) {
      var offX = event.layerX - canvas.offsetLeft;
      var offY = event.layerY - canvas.offsetTop;
      alert(offX + ',' + offY);
    }

    function mouseDown(event) {
      isDrawingNow = true;
      var offX = event.layerX - canvas.offsetLeft;
      var offY = event.layerY - canvas.offsetTop;
      currentPoint = [offX, offY];
      event.stopPropagation();
    }

    function mouseUp(event) {
      isDrawingNow = false;
    }

    function mouseMove(event) {
      if (isDrawingNow === false) {
        return;
      }
      var offX = event.layerX - canvas.offsetLeft;
      var offY = event.layerY - canvas.offsetTop;
      if (Math.abs(offX - currentPoint[0] < 0.1)) {
        //return;
      }
      drawLine(currentPoint, [offX, offY]);
      currentPoint = [offX, offY];
      event.stopPropagation();
    }

    function mouseDoubleClick(event) {
      resetCanvas();
      event.stopPropagation();
    }

    function drawLine(point1, point2) {
      context.beginPath();
      context.moveTo(point1[0], point1[1]);
      context.lineTo(point2[0], point2[1]);
      context.stroke();
      context.closePath();
    }

    // Get bitmap from the Canvas context and convert it to 28x28 bitmap.
    // Return value is an array of size 28x28 representing greyscale values.
    function getBitmap() {
      let width = 300;
      let height = 300;
      let newWidth = 28;
      let newHeight = 28;
      let bitmap = context.getImageData(0, 0, width, height);
      let greyscale = convertToGreyscale(bitmap.data);
      let resultBitmap = convertBitmap(greyscale, height, width, newHeight, newWidth);
      let output = analyze(resultBitmap);
      display(output);
    }

    // Convert Canvas bitmap to greyscale, taking Alpha values.
    // White is 0, black is 255
    function convertToGreyscale(bitmap) {
      let greys = [];
      for (let i = 0; i < bitmap.length; i += 4) {
        let grey = bitmap[i + 3]; // Alpha value
        greys.push(grey);
      }
      return greys;
    }

    // For a given bitmap array (greyscale) of any size,
    //  convert it to another size.
    function convertBitmap(bitmap, oldHeight, oldWidth, newHeight, newWidth) {
      let newBitmap = [];
      let blockHeight = Math.floor(oldHeight / newHeight);
      let blockWidth = Math.floor(oldWidth / newWidth);

      function getBlockAvg(topLeft) {
        let sum = 0.0;
        for (let i = topLeft[0]; i < topLeft[0] + blockHeight; i++) {
          for (let j = topLeft[1]; j < topLeft[1] + blockWidth; j++) {
            sum += bitmap[oldWidth * i + j];
          }
        }
        return Math.floor(sum / (blockHeight * blockWidth));
      }
      for (let i = 0; i < newHeight; i++) {
        for (let j = 0; j < newWidth; j++) {
          let topLeft = [Math.floor(oldHeight * i / newHeight),
            Math.floor(oldWidth * j / newWidth)
          ];
          let avg = getBlockAvg(topLeft);
          newBitmap.push(avg);
        }
      }
      return newBitmap;
    }

    function analyze(bitmapData) {
      var start_time = Date.now();
      let output = runNetwork(neuralNetwork, bitmapData, Math.tanh);
      var duration = Date.now() - start_time;
      //alert(start_time);
      return [process_data(output), duration / 1000];
    }

    function display(data_and_duration) {
      //alert('AI result: ' + JSON.stringify(output.slice(0, 3)));

      var data = data_and_duration[0];
      $('#lib-calvin-01').text(data[0][0] + ' (' + data[0][1] + '%)');
      $('#lib-calvin-02').text(data[1][0] + ' (' + data[1][1] + '%)');
      $('#lib-calvin-03').text(data[2][0] + ' (' + data[2][1] + '%)');

      $('#lib-calvin-time').text(data_and_duration[1]);
    }

    // Argument is array of ten floats, each of which denotes the probability
    //  of the handwriting being that digit.
    function process_data(data) {
      data = data.map((val, index) => {
        return [index, Math.round(val * 100)]
      });
      data.sort((a, b) => {
        return b[1] - a[1];
      });
      return data;
    }

    function resetDisplay() {
      $('#amazon-result').text('?');

      $('#amazon-time').text('?');
      $('#lib-calvin-time').text('?');

      $('#lib-calvin-01').text('?');
      $('#lib-calvin-02').text('?');
      $('#lib-calvin-03').text('?');
    }

  </script>
</head>

<body>

  <h1>Neural network implemented in C++</h1>
  <p>Write a single digit number with your mouse and click the "Guess" button.</p>
  <p>Click outside the box to reset.</p>

  <div style="overflow: auto;" id="out-of-canvas">
    <div id="input-canvas-container">
      <canvas id="input-canvas" width="300px" height="300px"></canvas>
      <!-- <canvas id="input-canvas""></canvas> -->
    </div>
  </div>

  <div>
    <button style="margin:0 auto" onclick="getBitmap();">Guess</button>
  </div>

  <div style="margin-top:50px">
    <table style="width:300px; margin: 0 auto; text-align: center;">
      <tr>
        <th></th>
        <th>Inference result</th>
      </tr>
      <tr>
        <th>Execution time</th>
        <td id="lib-calvin-time">?</td>
      </tr>
      <tr>
        <th>1st guess</th>
        <td id="lib-calvin-01">?</td>
      </tr>
      <tr>
        <th>2nd guess</th>
        <td id="lib-calvin-02">?</td>
      </tr>
      <tr>
        <th>3rd guess</th>
        <td id="lib-calvin-03">?</td>
      </tr>
    </table>
  </div>

  <pre id="response"></pre>

</body>

</html>